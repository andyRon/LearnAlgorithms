算法图解
----

https://www.manning.com/books/grokking-algorithms

https://github.com/egonschiele/grokking_algorithms

## 1 算法简介



### 1.2 二分查找

二分查找是一种算法，其输入是一个**有序**的元素列表。如果要查找的元素包含在列表中，二分查找返回其位置；否则返回null。

一般而言，对于包含n个元素的列表，用二分查找最多需要log2n步，而简单查找最多需要n步。

10100=2。对数运算是幂运算的逆运算。

![image-20220330080721962](images/image-20220330080721962.png)

### 1.3 大O表示法

算法的速度

![image-20220330084436684](images/image-20220330084436684.png)

随着元素数量的增加，二分查找需要的额外时间并不多，而简单查找需要的额外时间却很多。

简单查找的运行时间为O(n)，二分查找的运行时间为O(log n)。

大O表示法指出了最糟情况下的运行时间。例如，简单查找O(n)，表示最多查找n次，当然也有可能第1次就找到了。

#### 常见的大O运行时间

- O(log n)，也叫对数时间，如二分查找。
- O(n)，也叫线性时间，如简单查找。
- O(n ＊ log n)，如快速排序。
- O(n^2^)，如选择排序。
- O(n! )



#### 旅行商问题

一位旅行商，他准备需要前往n个城市，在所有路线中选取旅程最短的。

所有路线的数量就n的阶乘(n!)，大O表示为O(n!)



 算法运行时间并不以秒为单位，是从其增速的角度度量的，用大O表示法表示。



## 2 选择排序

很多算法仅在数据经过排序后才管用。

需要存储多项数据时，有两种基本方式——数组和链表。

### 数组和链表

Facebook存储用户信息时使用的既不是数组也不是链表。假设Facebook使用的是一种混合数据：**链表数组**。这个数组包含26个元素，每个元素都指向一个链表。例如，该数组的第一个元素指向的链表包含所有以A打头的用户名，第二个元素指向的链表包含所有以B打头的用户名，以此类推。

![image-20220330095909859](images/image-20220330095909859.png)

查找时，其速度比数组慢，但比链表快；而插入时，其速度比数组快，但与链表相当。因此，其查找速度比数组慢，但在各方面都不比链表慢。

另一种混合数据结构——散列表。这个练习应该能让你对如何使用简单数据结构创建复杂的数据结构有大致了解。

Facebook实际使用的是什么呢？很可能是十多个数据库，它们基于众多不同的数据结构：散列表、B树等。数组和链表是这些更复杂的数据结构的基石。



#### 选择排序

基本思想是: 首先在未排序的数列中找到最小(or最大)元素，然后将其存放到数列的起始位置；接着，再从剩余未排序的元素中继续寻找最小(or最大)元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。



## 3 递归

恨它的、爱它的以及恨了几年后又爱上它的

伪代码是对手头问题的简要描述，看着像代码，但其实更接近自然语言。

“如果使用循环，程序的性能可能更高；如果使用递归，程序可能更容易理解。如何选择要看什么对你来说更重要。”

### 基线条件和递归条件

由于递归函数调用自己，因此编写这样的函数时很容易出错，进而导致无限循环。

编写递归函数时，必须告诉它何时停止递归。正因为如此，每个递归函数都有两部分：

**递归条件**（recursive case）指的是函数调用自己；

**基线条件**（base case）指的是函数不再调用自己，从而避免形成无限循环。

![image-20220401100930939](images/image-20220401100930939.png)

![](images/image-20220401100942105.png)

### 调用栈



## 4 快速排序

### 分而治之

分而治之（divide and conquer, D&C）——一种著名的递归式问题解决方法。

使用D&C解决问题的过程包括两个步骤：

1. 找出基线条件，这种条件必须尽可能简单。
2. 不断将问题分解（或者说缩小规模），直到符合基线条件。

### 快速排序

C语言标准库中的函数qsort实现的就是快速排序。快速排序也使用了D&C。

### 再谈大O表示法

快速排序的独特之处在于，其速度取决于选择的基准值。

快速排序的情况比较棘手，在最糟情况下，其运行时间为O(n^2^)，在平均情况下，是O(nlog n)。



大O表示法中的常量有时候事关重大，这就是快速排序比合并排序快的原因所在。

## 5 散列表

### 5.1 散列函数

散列函数：无论你给它什么数据，它都还你一个数字。

使用散列函数和数组创建了一种被称为**散列表**（hash table）的数据结构。

### 5.2 应用案例

#### 将散列表用于查找



#### 防止重复



#### 将散列表用作缓存



散列表适合用于：

- 模拟映射关系；
- 防止重复；
- 缓存/记住数据，以免服务器再通过处理来生成它们。

### 5.3 冲突

要明白散列表的性能，你得先搞清楚什么是冲突。

处理冲突的方式很多，最简单的办法如下：如果两个键映射到了同一个位置，就在这个位置存储一个链表。

### 5.4 性能

要避免冲突，需要有：较低的填装因子； 良好的散列函数。

#### 填装因子



#### 良好的散列函数



## 6 广度优先搜索

广度优先搜索（breadth-first search, BFS）能够找出两样东西之间的最短距离，不过最短距离的含义有很多！

### 6.1 图简介

最短路径问题（shorterst-pathproblem）

### 6.2 图是什么

图由节点（node）和边（edge）组成。

图用于模拟不同的东西是如何相连的。

### 6.3 广度优先搜索

广度优先搜索是一种用于图的查找算法，可帮助回答两类问题。

- 第一类问题：从节点A出发，有前往节点B的路径吗？
- 第二类问题：从节点A出发，前往节点B的哪条路径最短？



## 7 狄克斯特拉算法

狄克斯特拉算法（Dijkstra's algorithm）能够找出加权图中前往X的最短路径。

### 7.1 使用狄克斯特拉算法

1. 找出最便宜的节点，即可在最短时间内前往的节点。
2. 对于该节点的邻居，检查是否有前往它们的更短路径，如果有，就更新其开销。
3. 重复这个过程，直到对图中的每个节点都这样做了。
4. 计算最终路径。

权重（weight）



### 负权边



## 8 贪婪算法

### 8.1 教室调度问题



### 8.2 背包问题



### 8.3 集合覆盖问题



#### 8.4 NP完全问题



## 9 动态规划



## 10 K最近邻算法



### 创建推荐系统



## 11

### 树



### 反向索引



### 傅里叶变换



### 并行算法



### MapReduce



### 布隆过滤器和HyperLogLog



### SHA算法



### 局部敏感的散列算法



### Diffie-Hellman密钥交换



### 线性规划



